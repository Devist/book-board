## 1. 결과물 확인

```bash
# 의존성 설치
$ npm i

# 핫 리로드 localhost:8080
$ npm run serve

# 빌드하기
$ npm run build

# 빌드 결과물 실행
$ npm run preview

# 테스트 실행
$ npm run test


```

## 2. 개발 환경 및 선정 이유

### typesciprt

가장 익숙한 것은 vue를 사용하는 것이지만, 이번 기회에 순수환경에서 타입스크립트만으로 clean architecture 및 atomic design 패턴을 적용해보고 싶었습니다.

### axios

단순 조회용 API 1개만 있어 fetch() 를 사용할까 고민했지만, 더 확장성 있는 구조를 가져가기 위해 axios를 사용하였습니다.

## 3. 요구사항

빠져있다 생각하는 요구사항은 다음과 같이 정했습니다.

- name 이 없을 경우 '없음' 으로 표시한다.
- title이 없을 경우 '없음'으로 표시한다.
- aliases 가 없을 경우 '없음'으로 표시한다.
- 초기화 버튼 클릭시, 필터도 해제된다.



## 4. 작업시 고민 과정

### 테스트

최근 클린 아키텍쳐 기반으로 각 단계별 독립적으로 테스트를 실행하는 것에 관심이 생겼습니다. 현재 저의 업인 SI 특성상, 짧은 구현 기간 안에 가장 중요한 것은 유저의 사용과 직접적으로 연관 있는 E2E테스트라고 생각합니다. 다만 과제에서는 일부 레이어(엔티티)에 대하여 단위 테스트를 진행하기로 했습니다.

### Entity

api response를 통해 Entity를 작성할 때 api에서 값이 없을 경우, 

- 어떤 property는 빈 배열로, 
- 어떠한 property는 [""]와 같은 배열로

왔습니다. ['']와 같은 배열은 의미가 없다고 판단하여, 빈문자열은 제거하는 것으로 결정했습니다.

리스트의 경우 ICharacterData 로, 하나의 캐릭터에 대한 상세 정보는 Character 클래스를 객체화하여 서비스 단에서 이용하려고 했습니다. 그러나 실질적으로 리스트 페이지만 있으므로, ICharacterData 만 사용하였습니다.

### Service

usecase의 대부분을 서비스 레이어에 작성하여 비즈니스 로직을 분리하려 했으나, 실무와 달리 삭제,필터 같은 usecase가 내부에서 동작(통신없이 브라우저 내에서만 동작)합니다

따라서 리스트를 가져오는 케이스 외에는 presenter 레이어에서 처리하기로 결정했습니다. 하지만 순수 환경에서 요구사항을 바탕으로 presenter를 구현하기에 어려움을 느껴 UI 단에서 처리하였습니다.

### UI

- 필터링 및 초기화 : 실무에서는  리스트 또는 테이블의 필터링시 업데이트 된 값도 사용하기 위하여 서버와 통신하여 신규 데이터로 처리해 왔습니다. 또한 필터링된 결과값은 vue, react 등에서 실제 배열 객체의 값을 조작하여 화면을 갱신하였습니다. 데이터를 한번에 불러와 처리하게 되는 경우에도, 실제 배열 객체의 값을 조작하여 처리했었습니다. 그러나 과제에서는 배열 객체의 조작 없이 검색 결과를 바탕으로 화면의 display 선택자의 조작으로 처리하였습니다. 그러다보니 presenter 레이어를 별도로 두기가 생각보다 난해하게 느껴졌고, 일부 로직이 UI에 포함되게 되었습니다.
- 무한스크롤 : 스크롤할때 debounce를 이용하여 offset 위치를 확인하여 처리하는 방법으로 구현해왔으나, 이번 과제에서 전반적으로 직접 구현하는 과정에서 **IntersectionObserver** 를 통해 성능 부하를 크게 줄이는 방법이 있다는 것을 알게되어, 이를 적용해 보았습니다.
